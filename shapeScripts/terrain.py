#! /usr/bin/env python

import numpy as num, pylab as pyl, pyfits as pyf,pickle as pick,os
from pixTimes import getPixTimes,getVels
from shapeLib import *
import pixelLatLong as pll
from MChandler import getFit
import specAnalysis
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.collections import PolyCollection
from matplotlib import colors
import pickle as pick
from pds.imageextractor import ImageExtractor
from pds.core.common import open_pds
from matplotlib import image as mpimg
from scipy.interpolate import griddata


###for removing trailing zeros on contours
class nf(float):
     def __repr__(self):
         str = '%.1f' % (self.__float__(),)
         if str[-1]=='0':
             return '%.0f' % self.__float__()
         else:
             return '%.1f' % self.__float__()

######
#test comparisons between the PDS image and the coordinate system generated by my lons/lats scripts below shows that they agree.
#used junk.py to generate a crater map, compared that with PhoebeFull.tiff. Good example, in my map, a crater at -116 to -103, which
#corresponds to ~118-103 left of 0, and 244 to 257 in the sbmt display
#all three coordinate systems agree!*******
######
def getPars(fn):
    with open(fn) as han:
        r=han.readlines()
    vc=float(r[0].split()[0])
    vi=float(r[1].split()[0])
    s=r[2].split()[0].split(',')
    oxv=float(s[0])
    oyv=float(s[1])
    s=r[3].split()[0].split(',')
    oxi=float(s[0])
    oyi=float(s[1])
    try:
        s=r[4].split()
        dn=float(s[0])
    except:
        dn=None
    return (vc,vi,oxv,oyv,oxi,oyi,dn)



pyl.rcParams['contour.negative_linestyle'] = 'dashed'


"""
#for the PDS maps
ie = ImageExtractor()
(img, labels) = ie.extract(open_pds('/data/PhoebePDSMaps/SP_1M_0_0_MERCATOR.IMG'))
img.save('Mercator.png')
sys.exit()
"""
newImage=mpimg.imread('/data/PhoebePDSMaps/PhoebeFull.png')
newImage=newImage[:,:,0:3]

#load the shape model

###use the following as reference for plotting
#http://stackoverflow.com/questions/18897786/transparency-for-poly3dcollection-plot-in-matplotlib
x=1
n=(64*x)+1
with open('/Volumes/data/PhoebeShapeModel/CO_SA_ISSNA_5_PHOEBESHAPE_V2_0/data/phoebe_ver%sq.tab'%(n-1)) as han:
    data=han.readlines()

vertices=[]
for i in range(1,6*n**2+1):
    s=data[i].split()
    v=[float(s[1]),float(s[2]),float(s[3])]
    vertices.append(v)

vertices=num.array(vertices)

#get the vertices indices
vertIndices=[]
for i in range(6*n**2+2,len(data)):
    s=data[i].split()
    vertIndices.append([int(float(s[1]))-1,int(float(s[2]))-1,int(float(s[3]))-1])
vertIndices=num.array(vertIndices)

vertlons=(num.arctan2(vertices[:,1],vertices[:,0])*r2d)#%360
vertlats=num.arcsin(vertices[:,2]/(vertices[:,0]**2+vertices[:,1]**2+vertices[:,2]**2)**0.5)*r2d
vertLl=num.zeros((len(vertlons),2)).astype('float64')
vertLl[:,0]=vertlons
vertLl[:,1]=vertlats
vivll=vertLl[vertIndices]
#vivll[:,:,0]=(vivll[:,:,0]-180)%360-180
whichVertsToPlot=[]
for i in range(len(vivll)):
    #print num.max(vivll[i,:,0])-num.min(vivll[i,:,0])
    if num.max(vivll[i,:,0])-num.min(vivll[i,:,0])<300:
        whichVertsToPlot.append(i)
whichVertsToPlot=num.array(whichVertsToPlot)

"""
#testing
cmap=pyl.get_cmap('jet')
lLCollection=PolyCollection(vivll[whichVertsToPlot])
collectionColours=cmap(num.ones(len(vivll)))
collectionColours[:,3]=0.8
lLCollection.set_facecolors(collectionColours[whichVertsToPlot])
lLCollection.set_linewidths(0.0)


fig=pyl.figure()
sp=fig.add_subplot(111)
ax=sp.add_collection(lLCollection)
cheat=sp.scatter([-10,-10],[100,100],c=num.array([0,1]))
pyl.colorbar(cheat)
sp.set_xlim(0,360)
sp.set_ylim(-90,90)
pyl.show()
sys.exit()
#end testing
"""


#get the vertices indices
(mids,normals)=midsNormals(vertices[vertIndices])
lons=(num.arctan2(mids[:,1],mids[:,0])*r2d)#%360
lats=num.arcsin(mids[:,2]/(mids[:,0]**2+mids[:,1]**2+mids[:,2]**2)**0.5)*r2d
D=(mids[:,0]**2+mids[:,1]**2+mids[:,2]**2)**0.5
meanRadius=num.median(D)
print 'Median radius is:',meanRadius

gridLong=num.linspace(num.min(lons),num.max(lons),360*10)
gridLat=num.linspace(num.min(lats),num.max(lats),360*10)
gridD=griddata((lons,lats),D,(gridLong[None,:],gridLat[:,None]),method='linear')


lons=lons%360



resolutions=[]
imageNames=['2004163T121836_2004163T192848/cv1465661929_1',
            '2004163T121836_2004163T192848/cv1465662167_1',
            '2004163T121836_2004163T192848/cv1465662631_1',
            '2004163T121836_2004163T192848/cv1465664774_1',
            '2004163T121836_2004163T192848/cv1465665036_1',
            '2004163T121836_2004163T192848/cv1465665440_1',
            '2004163T121836_2004163T192848/cv1465665563_1',
            '2004163T121836_2004163T192848/cv1465665771_1',
            '2004163T121836_2004163T192848/cv1465666573_1',
            '2004163T121836_2004163T192848/cv1465667330_1', 
            '2004163T121836_2004163T192848/cv1465667594_1',
            '2004163T121836_2004163T192848/cv1465667721_1',
            '2004163T121836_2004163T192848/cv1465669068_1',
            '2004163T121836_2004163T192848/cv1465669741_1',
            '2004163T121836_2004163T192848/cv1465669944_1',
            '2004163T121836_2004163T192848/cv1465670212_1',
            '2004163T121836_2004163T192848/cv1465670650_1',
            '2004163T121836_2004163T192848/cv1465671822_1',
            '2004163T121836_2004163T192848/cv1465672161_1',
            '2004163T193015_2004164T051726/cv1465678419_1',
            '2004163T193015_2004164T051726/cv1465678911_1',
            '2004163T193015_2004164T051726/cv1465679413_1',
            '2004163T193015_2004164T051726/cv1465679675_1',
            '2004163T193015_2004164T051726/cv1465680977_2',
            '2004163T193015_2004164T051726/cv1465680977_5']
    
dumpDepths=True

for imageName in imageNames:
    if not dumpDepths:continue
    waterDepths=[]
    siliDepths=[]
    for jj in range(len(mids)):
        waterDepths.append([])
        siliDepths.append([])
        
    print 'Working with image:'
    print imageName


    (visDataMin,IRDataMin,oxv,oyv,oxi,oyi,distancenot)=getPars('/Users/fraserw/data/VIMS/covims_0004/procdata/%s.parFile'%(imageName))
    offsetsVis=num.array([oxv,oyv])
    offsetsIR=num.array([oxi,oyi])

    with pyf.open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s_vis_mean.fits'%(imageName)) as han:
        imDataVis=han[0].data

    with pyf.open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s_vis_mean_bpmap.fits'%(imageName)) as han:
        maskVis=han[0].data
    imDataVis*=maskVis
    
    W=num.where(imDataVis<-10000)
    imDataVis[W]=num.median(imDataVis)
    maxi=num.max(imDataVis)
    W=num.where(imDataVis<maxi)
    maxi=num.max(imDataVis[W])
    imDataVis=num.clip(imDataVis,num.min(imDataVis),maxi)
   
   
    w=num.where(imDataVis>visDataMin)
    imDataVis[w]=256.
    W=num.where(imDataVis<256.)
    imDataVis[W]=0.0
    
    with pyf.open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s_ir_mean.fits'%(imageName)) as han:
        imDataIR=han[0].data
    
    
    W=num.where(imDataIR<-10000)
    imDataIR[W]=num.median(imDataIR)
    maxi=num.max(imDataIR)
    W=num.where(imDataIR<maxi)
    maxi=num.max(imDataIR[W])
    imDataIR=num.clip(imDataIR,num.min(imDataIR),maxi)
    
    
    w=num.where(imDataIR>IRDataMin)
    imDataIR[w]=256.
    IRBGPixels=num.where(imDataIR<256.)
    imDataIR[IRBGPixels]=0.0

    
    imData=num.concatenate([[imDataVis],[imDataIR],[maskVis]])
    (dump,A,B)=imData.shape
    
    
    with open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s_vis.campt.pickle'%(imageName)) as han:
        latLongObjVis=pick.load(han)
    
    with open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s_ir.campt.pickle'%(imageName)) as han:
        latLongObjIR=pick.load(han)
    
    
    
    
    
    sampResolutionsVis=[]
    #line is i, sample is j
    CassVis=[]
    for i in range(len(latLongObjVis)):
        for j in range(len(latLongObjVis[i])):
            if latLongObjVis[i][j]['SpacecraftPosition']<>None:
                sampResolutionsVis.append(latLongObjVis[i][j]['SampleResolution'])
                [X,Y,Z]=latLongObjVis[i][j]['SpacecraftPosition']
                CassVis.append([X,Y,Z,
                                pll.MJD(latLongObjVis[i][j]['UTC']),
                                latLongObjVis[i][j]['TargetCenterDistance'],
                                latLongObjVis[i][j]['Line ']-1,latLongObjVis[i][j]['Sample ']-1])
    CassVis=num.array(CassVis)
    args=num.argsort(CassVis[:,3])
    CassVis=CassVis[args]
    
    sampResolutionsIR=[]
    CassIR=[]
    for i in range(len(latLongObjIR)):
        for j in range(len(latLongObjIR[i])):
            if latLongObjIR[i][j]['SpacecraftPosition']<>None:
                sampResolutionsIR.append(latLongObjIR[i][j]['SampleResolution'])
                [X,Y,Z]=latLongObjIR[i][j]['SpacecraftPosition']
                CassIR.append([X,Y,Z,
                                pll.MJD(latLongObjIR[i][j]['UTC']),
                                latLongObjIR[i][j]['TargetCenterDistance'],
                                latLongObjIR[i][j]['Line ']-1,latLongObjIR[i][j]['Sample ']-1])
    
    CassIR=num.array(CassIR)
    args=num.argsort(CassIR[:,3])
    CassIR=CassIR[args]
    
    
    
    sampResolutionsIR=num.array(sampResolutionsIR)
    sampResolutionsVis=num.array(sampResolutionsVis)
    argI=num.argmin(sampResolutionsIR)
    timeDelt=num.abs(CassVis[:,3]-CassIR[argI][3])
    W=num.where(timeDelt==num.min(timeDelt))
    resolutions.append(sampResolutionsIR[argI])
    
    
    
    
    w=[[0]]
    inot=int(CassIR[w][:,5])#same as mid_i
    jnot=int(CassIR[w][:,6])#same as mid_j
    Tnot=CassIR[w][0][3]
    
    
    
    pixelTimesVis=getPixTimes(CassVis,imDataVis.shape[0],imDataVis.shape[1],Tnot,inot,jnot)
    pixelTimesIR=getPixTimes(CassIR,imDataIR.shape[0],imDataIR.shape[1],Tnot,inot,jnot)
    
    
    #distance units are in km, resolution units in km/pix
    [Xnot,Ynot,Znot]=CassIR[w][0][:3]
    if distancenot==None:
        distancenot=CassIR[w][0][4]
    else:
        Xnot*=distancenot/CassIR[w][0][0]
        Ynot*=distancenot/CassIR[w][0][0]
        Znot*=distancenot/CassIR[w][0][0]
    
    
    #nominal values from the VIMS manual are 0.17*3 and 0.5 mrad
    resRat=num.min(sampResolutionsVis[W])/sampResolutionsIR[argI]
    if resRat<0.5:
        pixScaleVis=0.17
    else:
        pixScaleVis=0.17*3
    pixScaleIR=0.5
    
    (junk,deltaXVis,deltaYVis,deltaZVis)=getVels(CassVis,pixelTimesVis,Xnot,Ynot,Znot,inot,jnot,polyOrder=2)
    (spaceCraftVectornot,deltaXIR,deltaYIR,deltaZIR)=getVels(CassIR,pixelTimesIR,Xnot,Ynot,Znot,inot,jnot,polyOrder=2)
    

    #load the best point
    if imageName<> '2004163T193015_2004164T051726/cv1465680977_5': 
        (bestPoint,goodSamps)=getFit('/Users/fraserw/data/VIMS/covims_0004/procdata/%s.fit_pickle'%(imageName))
        [long_o_not,lat_o_not,az_o_not,long_s,lat_s,az_s,distancenot,offXV,offYV,offXI,offYI,offsetVel,offsetVelAngle,chi]=bestPoint
    else:
        [long_o_not,lat_o_not,az_o_not,long_s,lat_s,az_s,distancenot,offXV,offYV,offXI,offYI,offsetVel,offsetVelAngle]=[56.0996532798, 22.0762964974, 83.1812446577,325.515775913, -36.5007226218, 4.66444444534,37660.7449174,199.06543933, 197.37789514, 537.211312984, 217.658682313,0.446094331964, 128.544304131]
        chi='fake'

    #print distancenot
    #print 
    print 'EMCEE best chi:',chi

    if os.path.isfile('/Users/fraserw/data/VIMS/covims_0004/procdata/%s.rand'%(imageName)):
        with open('/Users/fraserw/data/VIMS/covims_0004/procdata/%s.rand'%(imageName)) as randHan:
            randoms=randHan.readlines()
        for i in range(0,len(randoms),4):
            s=''
            for j in range(4):
                s+=randoms[i+j].split('\n')[0]
            s=s.split()
            rchi=float(s[len(s)-1])
            if rchi>chi:
                x=[]
                for j in range(1,len(s)-1):
                    x.append(float(s[j].split(']')[0]))
                x=num.array(x)
                [long_o_not,lat_o_not,az_o_not,long_s,lat_s,az_s,distancenot,offXV,offYV,offXI,offYI,offsetVel,offsetVelAngle]=x
                chi=rchi
        print 'RANDOM best chi:',chi
    offsetsVis=num.array([offXV,offYV])
    offsetsIR =num.array([offXI,offYI])

    sampleResolutionnot=pixScaleIR*distancenot/1000.
    print ' IR fitted nominal sample resolution:',sampleResolutionnot
    print ' IR header sample resolution:',sampResolutionsIR[argI]/1000.

    #print 'Vis nominal sample resolution:',num.min(sampResolutionsVis[W])
    
    #calculate the shape model
    (imageVis,poly3d,colours,rot_vert,vertsInPixelVis,chi)=shapeGen_VIMS(vertices,vertIndices,
                                                    long_o_not,lat_o_not,az_o_not,
                                                    long_s,lat_s,az_s,
                                                    distancenot,
                                                    offsetsVis, offsetVel,offsetVelAngle,
                                                    pixScaleVis,
                                                    inot,jnot,
                                                    deltaXVis,deltaYVis,deltaZVis,
                                                    lons,lats,
                                                    pixelTimesVis,
                                                    imData[0],vis=True,mask=imData[2])
    (imageIR,poly3d,colours,rot_vert,vertsInPixelIR,chi)=shapeGen_VIMS(vertices,vertIndices,
                                                    long_o_not,lat_o_not,az_o_not,
                                                    long_s,lat_s,az_s,
                                                    distancenot,
                                                    offsetsIR, offsetVel,offsetVelAngle,
                                                    pixScaleIR,
                                                    inot,jnot,
                                                    deltaXIR,deltaYIR,deltaZIR,
                                                    lons,lats,
                                                    pixelTimesVis,
                                                    imData[0],vis=False)

    #produce the image colour maps
    with pyf.open('/Users/fraserw/data/VIMS/covims_0004/procdata/'+imageName+'_ir.fits') as shan:
        IRspecData=shan[0].data
        
    (channels,A,B)=IRspecData.shape

    #for cc in range(channels):
    #    bg=num.median(IRspecData[cc,:,:][IRBGPixels])
    #    print bg
    #    IRspecData[cc,:,:]-=bg
        
    waterDepth=[]
    siliDepth=[]
    for l in range(A):
        waterDepth.append([])
        siliDepth.append([])
        for s in range(B):
            (w,spec)=specAnalysis.getSpec(IRspecData,l=l,s=s)
            med=num.nanmedian(spec)
            if med>0.0025: #could probably put this at 0.0025
                wat=specAnalysis.water(w,spec)
                sil=max(0.0,specAnalysis.silicate(w,spec))
                if wat>0:
                    waterDepth[len(waterDepth)-1].append(wat)
                else:
                    waterDepth[len(waterDepth)-1].append(0.0)
                siliDepth[len(siliDepth)-1].append(sil)
            else:
                waterDepth[len(waterDepth)-1].append(0.0)
                siliDepth[len(siliDepth)-1].append(0.0)
    waterDepth=num.array(waterDepth)
    siliDepth=num.array(siliDepth)
    
    x=[]
    y=[]
    z=[]
    for i in range(len(vertsInPixelIR)):
        for j in range(len(vertsInPixelIR[i])):
            m=mids[vertsInPixelIR[i][j].astype('int')]
            h=(m[:,0]**2+m[:,1]**2+m[:,2]**2)**0.5
            hmed=num.median(h)
            
            if not num.isnan(hmed):# and waterDepth[i,j]<>0:
                x.append(hmed)
                y.append(waterDepth[i,j])
                z.append(siliDepth[i,j])
                
                for k in range(len(vertsInPixelIR[i][j])):
                    #element0==1 we get bright red
                    #element1==1 we get bright green
                    #element2==1 we get bright navy blue
                    if waterDepth[i,j]<0.2:
                        colours[vertsInPixelIR[i][j][k]][0]=1.0#waterDepth[i,j]
                    elif waterDepth[i,j]<0.37:
                        colours[vertsInPixelIR[i][j][k]][1]=1.0
                    else:
                        colours[vertsInPixelIR[i][j][k]][2]=1.0
                    waterDepths[int(vertsInPixelIR[i][j][k])].append(waterDepth[i,j])
                    siliDepths[int(vertsInPixelIR[i][j][k])].append(siliDepth[i,j])
    if dumpDepths:

        with open('/Users/fraserw/data/VIMS/covims_0004/procdata/'+imageName+'_wd.pickle','w+') as han:
            pick.dump([waterDepths,siliDepths,sampleResolutionnot,x,y,z],han)

################
####plot parameters
showMapOverlay=True
showBinaryColours=False
showContours=True
numContours=25
minPix=1
showJason=True
showWaterScatter=True
showSilicates=True
if showMapOverlay:
    if showJason:
        fs=(24,12)
        alpha=0.4
    else:
        fs=(15,5)
        alpha=0.4
else:
    fs=(15,10)
    alpha=0.8
if not showSilicates:
    cMax=0.4
    cMin=0.15
    cbTitle='Water-ice Absorption'
else:
    cMax=0.38
    cMin=0.15
    cbTitle='Fe2+ Silicate Absorption'
whichRes='medHigh'
if whichRes=='high':
    #high res
    resLow=10
    resHigh=16
    title='High Resolution, <16 km/pix'
elif whichRes=='med':
    #med res
    resLow=16
    resHigh=22
    title='Medium Resolution, 22>r>16 km/pix'
elif whichRes=='low':
    #low res
    resLow=20
    resHigh=40
    title='Low Resolution, >22 km/pix'
elif whichRes=='medHigh':
    resLow=0.
    resHigh=20
    title='Finer half, <%s km/pix'%(resHigh)
elif whichRes=='medLow':
    resLow=20.
    resHigh=40
    title='Coarser half, >%s km/pix'%(resLow)
####
#################
            
resolutions=[]
waterDepths=[]
siliDepths=[]
Xs=[]
Ys=[]
Zs=[]
for jj in range(len(mids)):
    waterDepths.append([])
    siliDepths.append([])
for imageName in imageNames:
    with open('/Users/fraserw/data/VIMS/covims_0004/procdata/'+imageName+'_wd.pickle') as han:
        [wDs,sDs,res,x,y,z]=pick.load(han)
    if res>resHigh or res<resLow: continue
    print imageName,res
    resolutions.append(res)
    for jj in range(len(wDs)):
        if len(wDs[jj])>0 and wDs[jj][0]<>0.:
            waterDepths[jj].append(wDs[jj][0])
            #print wDs[jj][0]
        if len(sDs[jj])>0 and sDs[jj][0]<>0.:
            siliDepths[jj].append(sDs[jj][0])
    for jj in range(len(x)):
        Xs.append(x[jj])
        Ys.append(y[jj])
        Zs.append(z[jj])
Xs=num.array(Xs)
Ys=num.array(Ys)
Zs=num.array(Zs)

if showWaterScatter:
    fig2=pyl.figure(2)
    sp1=fig2.add_subplot(211)
    w=num.where(Ys>0)
    pyl.scatter(Xs[w],Ys[w])
    pyl.xlabel('Elevation (km)')
    pyl.ylabel('Water-Ice Absorption')
    sp2=fig2.add_subplot(212)
    w=num.where(Zs>0)
    pyl.scatter(Xs[w],Zs[w])
    pyl.xlabel('Elevation (km)')
    pyl.ylabel('Fe2+ Absorption')

x=[]
y=[]
meanWDs=[]
stdWDs=[]
taken=[]
cMeans=num.zeros(len(mids)).astype('float64')
cSTDs=num.zeros(len(mids)).astype('float64')
for i in range(len(waterDepths)):
    if len(waterDepths[i])>=minPix:
        #print waterDepths[i]
        if showSilicates:
            m=num.mean(siliDepths[i])
            s=num.std(siliDepths[i])
        else:
            m=num.mean(waterDepths[i])
            s=num.std(waterDepths[i])
        if m==0:continue
        #print waterDepths[i],m,s
        x.append(lons[i])
        y.append(lats[i])
        meanWDs.append(m)
        stdWDs.append(s)
        taken.append(i)
        cMeans[i]=m
        cSTDs[i]=s


c=num.array(cMeans)
s=num.array(cSTDs)
w=num.where(c[whichVertsToPlot]<>0)
cmap=pyl.get_cmap('jet')


lLCollection=PolyCollection(vivll[whichVertsToPlot][w],zorder=10)
col1=(c-cMin)/(cMax-cMin)
col1=num.clip(col1,0.,1.)
if showBinaryColours:
    ww=num.where(c>0.3)
    www=num.where(c<=0.3)
    col1[ww]=1.
    col1[www]=0.1
#wc=num.where(c>0.1)
#col1[:]=1.
collectionColours=cmap(col1)
collectionColours[:,3]=alpha
#collectionColours[w][:,3]=0.0
lLCollection.set_facecolors(collectionColours[whichVertsToPlot][w])
lLCollection.set_linewidths(0.0)

slLCollection=PolyCollection(vivll[whichVertsToPlot][w])
scollectionColours=cmap(s/num.max(s))
scollectionColours[:,3]=alpha
#collectionColours[w][:,3]=0.0
slLCollection.set_facecolors(scollectionColours[whichVertsToPlot][w])
slLCollection.set_linewidths(0.0)





meanWDs=num.array(meanWDs)
stdWDs=num.array(stdWDs)#/meanWDs
x=num.array(x)
y=num.array(y)

args=num.argsort(meanWDs)
x=x[args]
y=y[args]
meanWDs=meanWDs[args]
stdWDs=stdWDs[args]
print num.min(meanWDs),num.mean(meanWDs),num.max(meanWDs)
#meanWDs-=num.min(meanWDs)
#meanWDs/=num.max(meanWDs)

extent=[-180,180,-90,90]


fig1=pyl.figure(1,figsize=fs)
fig1.subplots_adjust(hspace=0)
if not showMapOverlay:
    sp1=fig1.add_subplot(211)#,xticklabels='')
else:
    sp1=fig1.add_subplot(111)
    sp1.imshow(newImage,interpolation='nearest',cmap='gray',extent=extent,zorder=1)
pyl.title(title)
sp1.add_collection(lLCollection)
ax1=pyl.scatter([-10,10],[100,100],c=num.array([cMin,cMax]))
cbar1 =fig1.colorbar(ax1,fraction=0.01)#, orientation='horizontal')
cbar1.set_label(cbTitle)
if showJason:
    sp1.set_xlim(-80,120)
    sp1.set_ylim(-40,60)
else:
    sp1.set_xlim(-180,180)
    sp1.set_ylim(-56.9534,56.9534)
pyl.ylabel('Latitude (deg)')

if showMapOverlay:
    if showContours:
        contours=pyl.contour(gridLong,gridLat,gridD-106,numContours,colors='w',zorder=5)
        contours.levels = [nf(val-int(meanRadius)) for val in contours.levels ]
        # Label levels with specially formatted floats
        if pyl.rcParams["text.usetex"]:
            fmt = r'%r'
        else:
            fmt = '%r'
        pyl.clabel(contours, contours.levels, inline=True, fmt=fmt, fontsize=14)

        #pyl.clabel(contours,inline=1,fontsize=10)
    pyl.show()
    sys.exit()

    
sp2=fig1.add_subplot(212,sharex=sp1,sharey=sp1)
sp2.add_collection(slLCollection)
ax2=pyl.scatter([-10,10],[100,100],c=num.array([0.0,1.0]))
cbar2 =fig1.colorbar(ax2,fraction=0.01)#, orientation='horizontal')
cbar2.set_clim(num.min(s),num.max(s))
sp2.set_xlim(-180,180)
sp2.set_ylim(-56.9534,56.9534)
pyl.ylabel('Latitude (deg)')
pyl.xlabel('Longitude (deg)')
pyl.show()
